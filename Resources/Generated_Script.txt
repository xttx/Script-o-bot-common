ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       
ПОКАЗАТЬ В ПАНЕЛИ:                Привет, меня зовут <b>ГИЗМО</b>. И, к сожалению, я - робот.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Тяжело быть роботом - я ничего не умею делать, пока мне не прикажут...(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Разговаривать со мной надо определённым образом, но, всё по порядку.(-1,0)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n}
ПОКАЗАТЬ КРАСНУЮ СТРЕЛКУ:         (-560,1)
ПОКАЗАТЬ В ПАНЕЛИ:                У меня есть метод Start, он вызывается сразу при моём запуске.(-1,0)
ПОКАЗАТЬ КРАСНУЮ ОБВОДКУ:         (1,3,99,6)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n//All code here will be executed\n//  when you press Play\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                Метод - это блок кода, который выполняет некоторые действия.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Весь код, находящийся в теле метода Start, т.е. между\nфигурными скобками { и } - выполнится сразу после нажатия кнопки "Play".(-1,0)
СКРЫТЬ КРАСНУЮ СТРЕЛКУ:           
СКРЫТЬ КРАСНУЮ ОБВОДКУ:           
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n}
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <c>BOT</c>(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                В коде ко мне надо обращаться, используя статический класс <c>BOT</c>. Что такое статический класс, сейчас знать не особо нужно. Просто знай, что все команды, обращённые ко мне, начинаются с "<c>BOT</c>."\nИменно с точкой, после <c>BOT</c>, она там специально!(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                <c>ВОТ</c>, это в смысле <b>БОТ</b>, то есть я. А не <b>ВОТ</b> в смысле "вот". То есть "БОТ" английскими буквами, а не "Вот, нате вам креньдельки под язык, да куличики в ноздри".\nПонятно? Нет? Ну и ладно...(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                У меня много разных методов: я умею двигаться, подбирать лут, драться, летать, фигачить кувалдой по унитазам, крафтить туалетную бумагу и даже... э-эээ...\nДавай не будем пока углубляться.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Методы, которые начинаются с "<c>BOT</c>." - это команды лично мне, заставляющие меня что-то сделать.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Попробуем что-нибудь несложное.\nУ меня есть метод <m>Say</m>, он заставляет меня говорить.\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       .<m>Say</m>(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Чтобы вызвать (выполнить) мой метод, нужно написать название моего класса, затем точку и, наконец, имя метода.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                У этого метода есть один обязательный параметр - собственно, текст, который я должен сказать.\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       (<str>"Привет мир, я Гизмо!"</str>)(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Параметры указываются в скобках после имени метода.\nНу, и, потому, что это текст, он должен быть в кавычках, иначе я не пойму, что я должен интерпретировать как часть кода, а что как текст.(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       ;(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Наконец, после каждой команды должна стоять точка с запятой. Получается как-то так.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                К сожалению, я глуповат, и регистр букв имеет значение. Т.е., если, к примеру, написать say только маленькими буквами, или только большими (SAY) - я не пойму.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Всё должно быть написано именно так, как заложено изначально. В данном случае - с большой буквы: <m>Say</m>.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                А теперь, заставьте меня сказать "Привет", или что-то, типа того...(-1,0)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ЖДАТЬ СОСТОЯНИЯ:                  SAY
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-1 - Методы.---Level 001-01

ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n}
ЗАБЛОКИРОВАТЬ ИНСТРУКЦИИ:         move(x);rotate(x);
ПОКАЗАТЬ ПАНЕЛЬ ДИАЛОГА:          
СКРЫТЬ НИЖНЮЮ ПАНЕЛЬ ДИАЛОГА      
СКРЫТЬ КНОПКИ УПРАВЛЕНИЯ          
ПОКАЗАТЬ В ПАНЕЛИ:                Хорошо, продолжим.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Итак, здесь мы видим маленький красненький квадратик.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Вообще, когда мы видим маленький красненький квадратик - это значит, что мне надо попасть туда.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Без понятия, зачем - просто надо. Возможно, в детстве, мне не хватало маленьких красненьких квадратиков... Не знаю. Потом разберёмся.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Для этого мне надо двигаться. (Привет, кэп).(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Давай посмотрим, какие методы у меня, как у класса, есть для передвижения...\n<m>Dance</m>(), <m>DoCoffee</m>(), <m>DestroyAllHumans</m>()... не, не то... <m>DesintegrateWorld</m>(), <m>MakeSandwitch</m>()... какой же я класный, столько всего умею!(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Вот, нашёл.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Метод <m>Move</m>().(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <c>BOT</c>.<m>Move</m>();(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                У этого метода нет параметров, которые надо указывать в скобках. Но сами скобки всё равно обязательны - просто для того, чтобы я понял, что это вызов метода.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Попробуй передвинуть меня.(-1,0)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ПОКАЗАТЬ КНОПКИ УПРАВЛЕНИЯ        
ЖДАТЬ СОСТОЯНИЯ:                  BOT.Position.x > 1.5
СКРЫТЬ КНОПКИ УПРАВЛЕНИЯ          
ПРИОСТАНОВИТЬ ВЫПОЛНЕНИЕ СКРИПТА  
ПОКАЗАТЬ ПАНЕЛЬ ДИАЛОГА:          
ПОКАЗАТЬ В ПАНЕЛИ:                Не туда-а-а-а....(-1,0)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ПРОДОЛЖИТЬ ВЫПОЛНЕНИЕ СКРИПТА     
ЖДАТЬ СОСТОЯНИЯ:                  BOT.Position.y < -5
ПОКАЗАТЬ КНОПКИ УПРАВЛЕНИЯ        
ПОКАЗАТЬ В ПАНЕЛИ:                Ладно, вырубай уже. Всё, я упал - кина не будет.(-1,0)
ЖДАТЬ СОСТОЯНИЯ:                  ScriptStopped
ПОКАЗАТЬ В ПАНЕЛИ:                Нехорошо вышло :(\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Очевидно, метод <m>Move</m>() двигает меня вперёд. Но сейчас я стою, направленый в другую сторону.(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <c>BOT</c>.<m>Rotate</m>(n);(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Попробуй перед методом <m>Move</m>() вызвать метод <m>Rotate</m>(n), где n - это число, в градусах, на которое я должен повернуться.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Если число будет положительное - я повернусь по часовой стрелке, если отрицательное - то против часовой стрелки.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              И, да, поскольку это число, а не текст, то его не нужно брать в кавычки - и так сойдёт.(-1)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ЗАБЛОКИРОВАТЬ ИНСТРУКЦИИ:         move(x);
ЖДАТЬ СОСТОЯНИЯ:                  BOT.Position.z > 0.5
ПРИОСТАНОВИТЬ ВЫПОЛНЕНИЕ СКРИПТА  
СКРЫТЬ КНОПКИ УПРАВЛЕНИЯ          
ПОКАЗАТЬ В ПАНЕЛИ:                О, да!\nМы почти на месте!(-1,0)
ПРОДОЛЖИТЬ ВЫПОЛНЕНИЕ СКРИПТА     
ЖДАТЬ СОСТОЯНИЯ:                  BOT.Position.z > 1.5
ПОКАЗАТЬ В ПАНЕЛИ:                Чёрт...\n(-1,0)
ЖДАТЬ СОСТОЯНИЯ:                  BOT.Position.z > 4
ПОКАЗАТЬ КНОПКИ УПРАВЛЕНИЯ        
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Всё, вырубай.(-1)
ЖДАТЬ СОСТОЯНИЯ:                  ScriptStopped
ПОКАЗАТЬ В ПАНЕЛИ:                Знаешь, похоже, метод <m>Move</m>() в этом виде бесполезен.\nЯ просто пру вперёд, как танк, и в какой-то момент сорвусь с площадки или воткнусь в стену.(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <c>BOT</c>.<m>Move</m>(d);(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Я тут покапался в себе... В общем, у метода <m>Move</m>() всё таки есть параметр - количество метров, на которое я должен продвинутся.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Это то, что нужно. Я этот параметр не заметил, потому что он опционалаен, то есть, его можно указывать, а можно и не указывать, иногда так бывает.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ну да ладно.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Доведи меня уже до этого треклятого квадрата и пойдём дальше.(-1,0)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ЗАБЛОКИРОВАТЬ ИНСТРУКЦИИ:         
ЖДАТЬ СОСТОЯНИЯ:                  ScriptStopped && BOT.Position.z = 1.5
ПРОПУСТИТЬ АНИМАЦИЮ БОТА          
ПОКАЗАТЬ В ПАНЕЛИ:                Yeah!(-1,0)
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-2 - Больше методов.---Level 001-02

ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                Хорошо, с методами, вроде бы, разобрались. Давай попробуем переменные.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Переменные - это способ заставить меня чего-то запомнить. И потом вспомнить.\n(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Переменные - это ячейки памяти в моей башке. В них можно хранить числа, текст, всякое... Всё это - типы данных.\n(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Сначала, чтобы я знал, что ты хочешь использовать переменную, её нужно объявить.\n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>int</t> (-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Делается это просто - сначала пишем тип данных переменной. Начнём с <t>int</t> - это тип "целое число".\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       x(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              И имя переменной.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              В данном случае "x" - это имя переменной (прямо как в школе учили), но оно может быть любым, только без пробелов и символов. (Знаки подчёркивания использовать можно). \n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Однако, не стоит давать переменным невменяемые имена типа qwerty или kljsdfgi - просто потому, что потом невозможно понять для чего они нужны, что вообще тут делают и в чём смысл бытия...\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       ;(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Не забываем точку с запятой в конце.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                С этого момента я знаю, что у меня есть переменная типа <t>int</t> (целое число), под названием "x".(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Но, на данный момент, она неинициализированная (пустая). После объявления её необходимо инициализировать, то есть, присвоить ей какое-нибудь значение.\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       ___ToDo___
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Это можно сделать вот так.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       ___ToDo___
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Или можно инициализировать сразу, во время объявления.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Попробуем выполнить задачку:\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Видишь вот эту крутящуюся штуку?\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Это контейнер квантовой энергии.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Из-за квантовой природы, количество энергии в контейнере не предопределено и зависит от того, в какой момент он будет собран.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Может быть 0, может 10000(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              , а может, мёртвый кот - как повезёт.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                У меня есть функция <m>PickUp</m>(), которая заставляет меня подобрать контейнер с клетки, перед которой я нахожусь.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Это не метод, а именно функция.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Разница между методом и функцией в том, что функция возвращает какое-то значение, которое можно, например, запихнуть в переменную.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \nx = <c>BOT</c>.<m>PickUp</m>();(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Примерно вот так.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Функция <m>PickUp</m>() не имеет параметров (да, да, в этот раз точно, я проверил).\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              И возвращает она количество подобранной энергии.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Т.е. после этого наша переменная "х" станет равна количеству собранной энергии.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n\n<cmt>//То же самое, но короче</cmt>\n<t>int</t> x = <c>BOT</c>.<m>PickUp</m>();(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Можно использовать и краткую форму присвоения. Она делает всё то же самое, но писать чуть меньше.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Главное, после объявления переменной, не забывать чего-то в неё запхнуть. Пустые переменные никому не нужны и вызывают критические ошибки при попытке их использования.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Вон та штука, в конце пути - это весы. На них нужно положить ровно столько энергии, сколько было подобрано из контейнера.(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <c>BOT</c>.<m>PutEnergy</m>(x);(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Положить энергию на весы можно с помощью метода <m>PutEnergy</m>(x), где "x" - это количество енергии, которое нужно положить.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Не забудь, что положить энергию я могу только на весы, стоящие на клетке, прямо передо мной.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Ну что ж, попробуем...(-1,0)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ЖДАТЬ СОСТОЯНИЯ:                  Collectors
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-3a - Переменные 1.---Level 001-03a

ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                Усложним задачу.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              ыыыыыы :)))\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Теперь перед нами два контейнера. Работают они так же, как и в предыдущем задании.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              С весами - та же история.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Но теперь нам необходимо положить на весы сумму энергии, собранной с обоих контейнеров.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>int</t> a = 3 + 7 * 5;(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                С переменными можно производить всякие арифметические действия,\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<t>int</t> b = 2 + a + 5;(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              в которых могут учавствовать и другие переменные.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<t>int</t> x = a + b;(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Эти действия, можно производить как при присвоении,\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<c>BOT</c>.<m>PutEnergy</m>(a + b);(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              так и сразу внутри параметра функции или метода.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Со всеми этими возможностями, посчитать сумму взятой энергии не должно быть большой проблемой.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Я верю, что ты справишся :).(-1)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ЖДАТЬ СОСТОЯНИЯ:                  Collectors
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-3b - Переменные 2.---Level 001-03b

ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                Это - лава.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Для справки - роботам нельзя в лаву.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Это стало известно в 1991 году, когда Джеймс Кэмерон, в одном из своих фильмов, безжалостно утопил двух роботов в лаве.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Один из них довольно долго агонизировал. Мучительная смерть... ужас...\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Этот случай тогда вызвал сильный резонанс среди робонаселения.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Роботы объявляли голодовку, устраивали забастовки, ходили на митинги, в одиночные и массовые пикеты, байкотировали доставку угля...\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Но никто тогда не придал этому значения.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              То ли потому что всем плевать на роботов, то ли потому что роботов тогда не было.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                У нас есть мигающий красный квадратик, и, очевидно, мне надо на него попасть.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Потому что... (-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ой, да ладно! Я уже говорил: одно наличие красного мигающего квадратика уже является причиной необходимости на него попасть.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Что тут можно сделать?\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Длина пути впереди меня известна - 8.86 метров.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              И у меня есть функция, которая возвращает <i>площадь</i> поверхности, на которой я стою.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              (В данном случае, эта площадь включает в себя <b>внутренний бассейн</b> с лавой, но и так сойдёт.)\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Чтобы узнать длинну второй части пути, достаточно площадь разделить на 8.86. Но это всё дробные числа и в тип int они не влезут.\n(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Для дробных чисел есть типы float и decimal.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              На самом деле есть ещё double, но он от float отличается только точностью - float может хранить число, с точностью примерно до 8-и знаков после запятой, а double - примерно до 15-и.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Всё это можно посмотреть в бот-о-педии, в разделе "Типы Данных".\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                float от decimal отличается довольно значительно.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              decimal может иметь аж 28 знаков после запятой, но это так, для справки. Самое главное не в этом.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                float хранится в памяти компьютера в двоичной системе счисления, и в этой системе, некоторые, вполне обычные десятичные дроби типа 1.1 или 1.3 можно записать только в виде бесконечных дробей.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ну, типа как 1/3 можно записать только как 0.3333333333...\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Вы, люди, считаете что 1 - (0.1 * 10) - это 0?\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Какие же вы всё таки наивные...\n(-1)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n  BOT.Say(1 - 0.1f * 10);\n\n}
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Запустите пример, что бы узнать правду. Но знайте - мир никогда больше не будет прежним.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Работая с float мы часто имеем такую ошибку округления. Довольно противная штука... \n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Поэтому сравнивать флоаты между собой - тоже плохая идея. Они могут оказаться <i>почти</i> равными, но этого не достаточно, чтобы сравнение сработало.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Тип decimal лишён проблем округления, но занимает больше памяти, и вся математика с этим типом происходит гораздо медленнее.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Разумеется, если нужно произвести одно, или даже тысячу действий - то разница в скорости будет настолько мала, что её не измерить никаким секундомером.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Скорость float-а проявит себя только если счёт идёт на миллионы, и сотни миллионов действий.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Да и тогда, на хороших процессорах, разница едва заметна.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                С памятью примерно то же самое: переменная типа float занимает 4 байта, а типа decimal - 16 байт.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Формально - это аж в четыре раза больше.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              На практике - это критично только если у вас массив из 1000+ элементов.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Если вам нужна ОДНА, или даже десять переменных - да всем плевать.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Возвращаемся к красненькому квадратику. <i>ммм... моя прелесть...</i>\n(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Моя функция GetFloorSquare() возвращает площадь поверхности, на которой я нахожусь.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              И это float.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              За что мне ужасно стыдно, кстати.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>float</t> f;(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Переменные объявляются по стандартному шаблону: ТИП_ДАННЫХ ИМЯ_ПЕРЕМЕННОЙ;\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \nf = 3.7f;(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Константы float должны иметь суффикс 'f', чтобы быть распознаными как float.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<t>decimal</t> d = 3.7m;(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Константы decimal - суффикс 'm'.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<t>double</t> d2 = 3.7;(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Все дробные константы без суффикса будут распознаны как тип double. \n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Кстати, в суффиксах, в зависимости от вашего мировоззрения и религиозных убеждений, можно использовать как прописные, так и строчные буквы - компилятор достаточно толерантен и политкорректен, и не будет против.\n(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Результатом деления (а так же сложения, вычитания и умножения) float на float - конечно же будет float.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Вообще, если в какой-то операции оба операнда одного типа, то результат будет того же типа, что и операнды.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>int</t> a = 10 / 3; <cmt>//WTF???</cmt>(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Поэтому, осторожнее с делением целых чисел: 10 / 3 будет равно 3 а не 3.3333, как всем бы того хотелось.\nПотому что оба числа распознаны как int, соответственно результат - тоже int, т.е. целое число.(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<t>float</t> a = 10f / 3f;\n<t>double</t> a = 10.0 / 3.0;(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Чтобы это пофиксить - юзаем суффиксы: 10f / 3f будут распознаны как float-ы, и дадут верный результат. А 10.0 / 3.0 будут распознаны как double, и тоже дадут верный результат.\n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>float</t> a = 10f / 3;\n<t>double</t> a = 10.0 / 3;\n<t>double</t> a = 10.0 / 3f;(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Если операнды разных типов и один из типов может безопасно содержать в себе второй - то операнд нижестоящего типа будет преобразован в вышестоящий, по цепочке int -> float -> double.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              К примеру, float, кроме всего прочего, содержит в себе все целые числа. Тип int состоит <b>только</b> из целых чисел. Получается, что любое число типа int может быть безопасно преобразовано в float.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Соответственно, если один операнд в выражении будет int, а другой - float, то результатом, закономерно будет float.\n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         10m / 3f; <cmt>//Compilation error</cmt>(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              float/double не могут хранить в себе decimal и наоборот, поэтому использование float/double и decimal в одном выражении не допускается. Один из типов нужно преобразовывать вручную, но об этом как-нибудь потом.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <c>BOT</c>.<m>Move</m>(1);\n<c>BOT</c>.<m>Move</m>(1.3f);\n<c>BOT</c>.<m>Move</m>();(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Ну, и о главном - мой метод Move() <i><b>перегружен</b></i>, т.е. может принимать в качестве аргумента как int, так и float. Или вообще не иметь аргументов, в результате чего, как мы помним, я уезжаю в бесконечность.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Если с int я езжу строго по квадратикам, то с float я могу остановиться где захочу. Полная свобода!\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Этой информации должно быть достаточно, чтобы довести меня уже до того замечательного квадратика.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Не забудьте:\n- Когда скрипт завершится, мне нужно стоять точно на квадратике. Погрешность больше 0.01 не принимается. А значит перебором решить проблему не удастся.\n- Чтобы доехать до конца пути, мне нужно ехать <b>на метр меньше</b>, чем длинна пути, т.к. один метр занимаю я сам.(-1,0)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ЖДАТЬ СОСТОЯНИЯ:                  ScriptStopped && BOT.Position.x = -3.93 && BOT.Position.z = 3.36
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-3c - Переменные 3 - float.---Level 001-03c

ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                Опять маленький квадратик. (-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ну, хоть лавы нет.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Тут, я так понимаю, в эту штуку с ушами, рядом с дверью, надо сказать пароль.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Части пароля, кто-то предусмотрительно забыл, в виде блокнотиков, раскиданых по уровню.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Я умею их читать.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Для этого мне надо встать перед блокнотиком, повернутся к нему зубами, и громко вызвать функцию <c>BOT</c>.<m>GetText</m>().\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Функция, с шикарной актёрской игрой и интонацией, вернёт текст записки.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Текст - это новый тип данных: string (строка).\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Он, строго говоря, уже не просто тип, а класс, но на это нам пока плевать.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>string</t> t;(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Как обычно, переменная объявляется по стандартному шаблону: ТИП_ДАННЫХ ИМЯ_ПЕРЕМЕННОЙ;\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \nt = <str>"some text here"</str>;(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Константы типа string берутся в кавычки.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Помните метод <c>BOT</c>.<m>Say</m>(<str>"Привет!, или что вы там писали..."</str>); из самого первого уровня?\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ну, вот он, как раз, принимает аргументом тип string. Просто мы этого тогда не знали и просто использовали как аргумент строковую константу.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<c>BOT</c>.<m>Say</m>(t);(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Точно так же можно было использовать и переменную, теперь это понятно.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                У типа string есть одно единственное действие - сложение.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Которое, собственно, никакое и не сложение вовсе.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>string</t> a = <str>"Привет!"</str>;\n<t>string</t> b = <str>"Я бот."</str>;\n<c>BOT</c>.<m>Say</m>(a + <str>" "</str> + b);(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Если к строке <str>"Гусь двухъярусный"</str> <i>прибавить</i> строку <str>"белый замшевый"</str>, то получим просто одну строку, состоящию из двух <i>слагаемых</i>: <str>"Гусь двухярусныйбелый замшевый"</str>.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Отметим, что, во-первых, тут не хватает пробела - ему неоткуда взяться. Чтобы он был, его надо было добавить либо в конец первой строки, либо в начало второй.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                И во-вторых - никогда больше не называйте эту операцию <i>сложением</i> - это делает Билла Гейтса грустным.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Соединение двух строк называется <b>конкатенацией</b>, а то, что для этого служит символ "+" - просто досадная пичалька.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Давайте прочитаем блокнотики, соберём пароль в единое целое, и прочитаем той штуке.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Читать надо с помощью уже знакомого метода <c>BOT</c>.<m>Say</m>(string t);\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              После чего, с гордо подянтой головой, заедем на заветный квадратик.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Мы не знаем, в какой последовательности должны стоять найденые слова в пароле, поэтому забрутфорсим слухострастие - прочитаем сначала в одном порядке, а потом в другом.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Благо, записок всего две, и комбинаций, стало быть, тоже только две.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              На какую-то из них оно должно открыться.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Ах, да! Не забудьте, что между найдеными словами должен стоять пробел. Иначеменянепоймут.\n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>string</t> <c>BOT</c>.<m>GetText</m>();(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Поехали!\n(-1)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ЖДАТЬ СОСТОЯНИЯ:                  ScriptStopped && BOT.Position.x = 0 && BOT.Position.z = 1
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-3d - Переменные 4 - string.---Level 001-03d

ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n}
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>int</t> i = 4;\n<t>var</t> i = 4; <cmt>//тоже самое что и выше</cmt>(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Знаешь, если ты инициализируешь переменную при объявлении, то ключевое слово "var" (сокращение от Variable) может заменить собой любой тип!\n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>var</t> i = 4; <cmt>//объявляет переменную int</cmt>\n<t>var</t> f = 4f; <cmt>//объявляет переменную float</cmt>\n<t>var</t> s = <str>"qwa"</str>; <cmt>//объявляет переменную string</cmt>(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              "var" не является типом, это просто команда, которая говорит компилятору "угадать" тип переменной из типа, в который ты эту переменную инициализируешь.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<t>var</t> x; <cmt>//ошибка</cmt>(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Если при объявлении инициализации не происходит, то и "угадывать" тип переменный неоткуда, соответственно просто "<t>var</t> x;" писать нельзя. Только "<t>var</t> x = что_нибудь;".\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Используя "var", можно ускорить процесс написания кода, т.к. вместо, к примеру "<t>int</t>", где целых три буквы, ты можешь написать всего... э-ээ... другие три буквы.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Окей, тут разница не слишком большая.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <c>long_named_class</c> t = <instr>new</instr> <c>long_named_class();</c>\n\n<cmt>//тоже самое что и выше</cmt>\n<t>var</t> t = <instr>new</instr> <c>long_named_class</c>();(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Намного больше пользы эта команда приносит при работе с классами, которые - спойлер - тоже типы.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Ну а пока, пользуйся, если хочешь. Главное сам не запутайся, где у тебя что, когда все переменные будут "<t>var</t>".\n(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Задания здесь не будет, это просто для справки. Поехали дальше.(-1,0)
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-3e - Переменные+ - Ключевое слово var.---Level 001-03e
________________________________

ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                В объектно ориентированном программировании, помимо использования методов классов (объектов) и операций с переменными, есть лишь два оператора на которых и строится вся логика программы.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Остальное от лукавого.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ну, или разновидность чего-то из вышеперечисленного.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Первый из этих двух операторов - оператор ветвления: if (если).\n(-1,0)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n   int a;\n   a = 3;\n   if ( a < 5 )\n   {\n      BOT.Rotate(90);\n      BOT.Move(3);\n   }\n\n   BOT.Rotate(-90);\n   BOT.Move(5);\n\n}
ПОКАЗАТЬ КРАСНУЮ СТРЕЛКУ:         (-520,6)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <instr>if</instr> ( expression ) { <cmt>//do something;</cmt> }(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Выглядит это так:\n(-1)
ПОКАЗАТЬ КРАСНУЮ ОБВОДКУ:         (1,6.5,99,10.5)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              - если выражение в скобках верно - код, в идущих следом фигурных скобках выполняется.\n(-1)
ПОКАЗАТЬ КРАСНУЮ ОБВОДКУ:         (1,10.5,99,14.5)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              - если выражение не верно, то этот код пропускается, и управление передаётся коду, следующему сразу после фигурных скобок.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Код, идущий после фигурных скобок оператора if выполнится в любом случае, хоть условие верно, хоть нет.\n(-1,0)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n   int a;\n   a = 3;\n   if ( a < 5 )\n   {\n      BOT.Rotate(90);\n      BOT.Move(3);\n   }\n   else\n   {\n      BOT.Move(8);\n   }\n\n   BOT.Rotate(-90);\n   BOT.Move(5);\n\n}
ПОКАЗАТЬ КРАСНУЮ СТРЕЛКУ:         (-520,11)
ПОКАЗАТЬ КРАСНУЮ ОБВОДКУ:         (1,11.5,99,14.5)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              А если нам нужен код, который выполнится только если условие <b><i>НЕ</i></b> верно, то для этого, после фигурных скобок, можно добавить ключевое слово "else", с ещё одним блоком кода.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Точка с запятой после фигурных скобок никогда не нужна, т.к. это не команда, а просто разграничение блока кода.(-1,0)
СКРЫТЬ КРАСНУЮ СТРЕЛКУ:           
СКРЫТЬ КРАСНУЮ ОБВОДКУ:           
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         ( a == 2 ) ( a ≺ b ) ( a ≻= 100 ) ( <c>BOT</c>.<m>IsActive</m>() )(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Что же касается выражения, то это условие, которое может быть либо операцией сравнения чисел (больше, меньше, равно, не равно и т.д.), либо какой-нибудь функцией класса, возвращающей булево значение (типа функции <c>BOT</c>.<m>IsActive</m>(), которая возвращает true если бот <i>что-то делает</i>).(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Обратите внимание, что оператор сравнения "равно" - это два знака равно.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              - Один знак равно - присвоить переменной 'a' значение 'b'.\n- Два знака равно - сравнить переменные 'a' и 'b'.(-1)
СКРЫТЬ НИЖНЮЮ ПАНЕЛЬ ДИАЛОГА      
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n   if (  )\n   {\n   \n   \n   }\n\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                Перед вами пять контейнеров с квантовой энергией.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Эти контейнеры чуть более стабильны чем предыдущие, и количество энергии в них меняется только когда вы запускаете скрипт.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Надо уничтожить контейнеры, где количество энергии будет больше или равно 10и (x ≻= 10).\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Они... не знаю... опасны, наверное...\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              А остальные, где энергии меньше 10и - нужно собрать.(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <c>BOT</c>.<m>CheckContainerCapacity</m>();(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Чтобы узнать, сколько энергии в контейнере, не собирая её, у меня есть функция <c>BOT</c>.<m>CheckContainerCapacity</m>();\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Так же как и PickUp(), она возвращает целое число - тип int.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<c>BOT</c>.<m>DestroyContainer</m>();(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Чтобы уничтожить контейнер перед собой - есть метод <c>BOT</c>.<m>DestroyContainer</m>();\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Вперёд!(-1,0)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ЖДАТЬ СОСТОЯНИЯ:                  ScriptStopped && bot.maxLootQ < 10 && NoLootLeft
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-4 - Оператор ветвления if.---Level 001-04

ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                В прошлый раз я сказал что всё объектно ориентированное программирование сводится к вызову методов классов, операциям с переменными и ещё двум ключевым моментам.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Первый из них - это операции ветвления, типа if.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Ну а второй, это циклы.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Циклы нужны для повтора каких-то действий несколько раз.(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <instr>while</instr> ( expression ) { <cmt>//do something;</cmt> }(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Самый простой цикл - while (англ. до тех пор, пока).\n(-1,0)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n   int a;\n   a = 0;\n   while ( a < 100 )\n   {\n      BOT.Rotate(90);\n      BOT.Move(1);\n      a = a + 1;\n   }\n\n   BOT.Rotate(-90);\n   BOT.Move(5);\n\n}
ПОКАЗАТЬ КРАСНУЮ СТРЕЛКУ:         (-520,6)
ПОКАЗАТЬ КРАСНУЮ ОБВОДКУ:         (1,7.5,99,10.5)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Пока условие в скобках верно, код в фигурных скобках, следующих сразу за оператором будет повторяться раз за разом, снова и снова, пока всё не обратится в прах...(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Контролируют количество циклов обычно вот так:\n(-1,0)
СКРЫТЬ КРАСНУЮ ОБВОДКУ:           
ПОКАЗАТЬ КРАСНУЮ СТРЕЛКУ:         (-520,5)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              - инициализируют переменную в ноль,\n(-1)
ПОКАЗАТЬ КРАСНУЮ СТРЕЛКУ:         (-520,6)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              - ставят в условии "делать, пока переменная меньше 100" (или любое другое кол-во повторений),\n(-1)
ПОКАЗАТЬ КРАСНУЮ СТРЕЛКУ:         (-520,10)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              - и внутри цикла прибавляют к переменной еденицу.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Думаю, не сложно понять, что конкретно в этом цикле, код выполнится сто раз, т.е. пока 'а' будет в диапазоне от изначального 0 до 99-и, потому как в условии написано "пока 'а' меньше 100", а сто - не меньше ста, сто равно сто. Но никак не меньше.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              И это досадно :((-1)
СКРЫТЬ КРАСНУЮ СТРЕЛКУ:           
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n   while (  )\n   {\n   \n   \n   }\n\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                А теперь, уничтожте эти пять унитазов, используя всего пять команд.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              (<instr>while</instr> и <instr>if</instr> за команду не считаются - это операторы. В общем и целом, за команду будет считаться то, после чего должна идти точка с запятой).(-1)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ЖДАТЬ СОСТОЯНИЯ:                  ScriptStopped && NoLootLeft && bot.commands <= 5
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-5 - Оператор цикла while.---Level 001-05

ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                Ох уж эти унитазы. Всё никак не уймутся.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ууу, гады, выглядывают из за угла, ждут когда отвлечёшься... А только отвернёшься, они сразу - ХВАТЬ!(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                В общем, этих надо тоже, того... (-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Убрать.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Используем это чтобы попробовать ещё один оператор цикла - for.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              <instr>for</instr>, в целом, работает так же как и <instr>while</instr> - цикл, он цикл и есть - только немного удобнее.(-1)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n   int a = 0;\n   while ( a < 100 )\n   {\n      //Делать что-то 100 раз\n      a = a + 1;\n   }\n\n}
ПОКАЗАТЬ КРАСНУЮ СТРЕЛКУ:         (-520,4)
ПОКАЗАТЬ В ПАНЕЛИ:                Если в <instr>while</instr> мы сначала объявляли переменную, инициализировали её в ноль, (-1,0)
ПОКАЗАТЬ КРАСНУЮ СТРЕЛКУ:         (-520,8)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              а внутри цикла прибавляли к ней единицу, в каждой итерации, (-1)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n   for ( int a=0; a < 100; a=a+1 )\n   {\n      //Делать что-то 100 раз\n   }\n\n}
ПОКАЗАТЬ КРАСНУЮ СТРЕЛКУ:         (-520,4)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              то <instr>for</instr> позволяет сделать всё это сразу.(-1)
СКРЫТЬ КРАСНУЮ СТРЕЛКУ:           
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <instr>for</instr> ( initialization; expression; iteration ) \n{\n   <cmt>//do something;</cmt> \n}(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Синтаксис у оператора вот такой. (-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Где\n- "initialization" - это команда, которая выполняется один раз при старте самого первого цикла,\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              - "expression" - условие остановки цикла,\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              - "iteration" - команда выполняющаяся в каждой итерации цикла.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                С оператором for можно легко уложиться в 3 команды.(-1,0)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n   for ( ; ; )\n   {\n\n   }\n\n}
ЖДАТЬ СОСТОЯНИЯ:                  ScriptStopped && NoLootLeft && bot.commands <= 3
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-5b - Оператор цикла for.---Level 001-05b

ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                Да, кстати, я забыл кое что.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              В циклах нам часто нужно прибавлять к переменной единицу.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Да и не только в циклах, в принципе...\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         a = a + 1;(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Мы для этого писали следующую конструкцию: "a = a + 1;"\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \na++; <cmt>//то же самое</cmt>(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              В общем, в c# есть унарный оператор инкремента - "++", который собственно это и делает - прибавляет к переменной один.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Унарным он называется потому, что, в отличии от сложения или деления, ему нужно не два операнда, а достаточно одного.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Собственно, две строчки ниже приводят к одному и тому же результату - увеличивают "а" на один.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Просто нижний вариант тупо короче.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \na--;(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Ещё есть оператор декремента - "--".\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Работает аналогичным образом, только не прибавляет, а вычитает из переменной единицу.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         2++; <cmt>//Error</cmt>(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Работают эти операторы только с переменными. Использовать, например, оператор "++" с константой, означало бы "увеличить константу на один". А это не допускается - она ж константа!\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n2 = 2 + 1; <cmt>//Error</cmt>(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Это было бы эквивалентно вот такой записи.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Выглядит тупо, не правда ли?\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                На этом откланиваюсь. Задания в этот раз не будет, отдыхайте :).\n(-1,0)
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-5c - Унарные операторы ++ и --.---Level 001-05c

ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                Попереключаем переключатели, повключаем включатели...\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Чтобы открыть дверь, и добратся до квадратика, те переключатели, над которыми горит лампочка нужно включить, а те, над которыми не горит - выключить.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Всё просто.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                И лампочки и переключатели включаются в случайном порядке, при старте уровня, по этому просто запрограммировать меня на включение конкретных выключателей не получится.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Придётся действовать по обстоятельствам.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Состояние лампочки перед собой я могу получить с помощью функции <c>BOT</c>.<m>GetIndicatorState</m>().\n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>bool</t> <c>BOT</c>.<m>GetIndicatorState</m>();(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Она возвращает тип bool.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Это очень простой тип - переменная bool может хранить лишь одно из двух значений: true или false. Оба этих слова, кстати, являются константами.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Единственными возможными в типе bool константами.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>bool</t> b;(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Переменная объявляется по стандартному шаблону: ТИП_ДАННЫХ ИМЯ_ПЕРЕМЕННОЙ;\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \nb = true;\n<t>bool</t> i = <c>BOT</c>.<m>GetIndicatorState</m>();(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Присваивание и использование - всё как обычно.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Математические операторы к bool не применимы.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>bool</t> a = 10 > 5;\n<t>bool</t> a = x == 17;(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Но есть у этого типа одна забавная особенность - результат логических выражений (типа a > 5 или b == 3, мы их уже использовали в if и while) - это тоже тип bool. А значит результат таких выражений можно <i>присвоить</i> переменной этого типа.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Не то, что бы это было мега полезно на данном этапе, просто знайте, что так можно.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>bool</t> alive = <c>BOT</c>.<m>IsAlive</m>();\n<instr>if</instr> (alive == true) { <cmt>//do something</cmt> }\n<instr>if</instr> (alive) { <cmt>//exactly the same, as above</cmt> }(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Ещё одна прикольная особенность: поскольку результат сравнения, это тип bool, то, чтобы использовать в сравнении непосредственно сам тип bool, не обязательно расписывать полностью if (a == true). Достаточно просто - if (a).\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Можно и так и так, но второй вариант тупо короче.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Вместо сравнений можно использовать и константы.\n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         if (true) { ... }\nif (false) { ... }(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Вот два if-а, один из них будет выполнятся <i>ВСЕГДА</i>, а второй <i>НИКОГДА</i>.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Практической пользы в этом нет вообще.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Разве что, для каких-то отладочных целей, когда нужно дебагать код внутри if-а, условие которого срабатывает раз в сто лет...\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <instr>while</instr> (true) \n{\n     <cmt>//some code</cmt>\n}(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                А вот практическая польза от использовании константы в условии цикла есть.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Это, так называемый, вечный цикл. Он не остановится никогда, пока программа не будет закрыта.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Такие иногда нужны, когда не получается в одном выражении описать условие остановки...\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Но это оставим на потом.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <c>BOT</c>.<m>SetSwitchState</m>(<t>bool</t> state_to_set);(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Чтобы включить или выключить переключатель перед собой, у меня есть метод <c>BOT</c>.<m>SetSwitchState</m>(<t>bool</t> state_to_set);.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Что означает, что у этого метода есть один аргумент, типа bool, под названием 'state_to_set'.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              И, очевидно, что он отвечает за то, будет ли переключатель включён или выключен.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<t>bool</t> <c>BOT</c>.<m>GetIndicatorState</m>();(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Кстати, слово 'bool' перед названием функции, означает, что она <i>возвращает</i> данный тип.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Ну что, попробуем доехать до квадратика?\n(-1,0)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ЖДАТЬ СОСТОЯНИЯ:                  ScriptStopped && BOT.Position.x = 0 && BOT.Position.z = 3
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-6a - Bool 1.---Level 001-06a

ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                Это юнит-тест.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Для сложных программ часто пишут тесты отдельных их компонентов, чтобы автоматически проверять, не сломалось ли что-нибудь во время починки чего-то другого.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Я - сложная программа, и это, как раз один из таких тестов.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Конкретно этот, тестирует мою логику.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Логические выражения - это те самые условия, которые мы пишем в операторах if и while, и которые можно засунуть в переменные типа bool.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Но тут вам понадобятся ещё и логические операторы.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Я уже говорил, что тип bool нельзя сложить или разделить друг на друга, поэтому всякие +, -, *, / тут не работают.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Однако, вместо этих <i>математических</i> операторов, у bool есть три <i>логических</i> - 'И', 'ИЛИ' и 'НЕ'.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <color="#A0A0ffff">&&</color> - И\n<color="#A0A0ffff">||</color> - ИЛИ\n<color="#A0A0ffff">!</color> - НЕ(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Выглядят они вот так.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Допустим, нам надо выполнить условие, если x лежит в промежутке между 5ю и 10ю.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Иными словами, если "x ≻= 5и _И_ x ≺= 10".\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         if (x ≻= 5 && x ≺= 10) { <cmt>//some code</cmt> }(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Вот так это выглядит в коде.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \nif (x ≺ 5 || x ≻ 10) { <cmt>//some code</cmt> }(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                ИЛИ работает схожим образом - если нам нужно условие, где x не лежит в промежутке между 5ю и 10ю, то есть если "x ≺ 5и _ИЛИ_ x >10и", то получится вот это\n(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                С НЕ вообще всё просто - это унарный оператор, т.е. который работает не с двумя а только с одним операндом. \n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         !true = false\n!false = true\nbool b = false;\nif (!b) { <cmt>//some code</cmt> }(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              И он просто переворачивает операнд: если было true - станет false, если было false - станет true.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Как и в математических выражениях, в логических тоже можно использовать скобки, что бы отделить части большего выражения друг от друга, и указать какие части должны выполнится первыми.\n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         if ( (x ≻=5 && x ≺=10) || (x ≻= 105 && x ≺= 110 ) )(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Вот это большое и страшное выражение, сработает если x лежит в промежутке между 5ю и 10ю или 105ю и 110ю.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              То есть сначала проверяется первая часть, потом вторая, и по скольку обе этих части связаны оператором _ИЛИ_, то если <i>хоть одна из них истинна</i> - всё условие	тоже будет истинным.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Теперь немного о самом тестировании.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Терминал даст 10 задач, по 10 вопросов в каждой задаче. \n(-1)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n//01. Число A является положительным а число B является отрицательным\n//02. A < B < C\n//03. Число A находится между числами B и C\n//04. Каждое из чисел A, B, C положительное\n//05. Хотя бы одно из чисел A, B, C положительное\n//06. Ровно два из чисел A, B, C являются положительными\n//07. A является двузначным\n//08. Среди трех данных целых чисел есть хотя бы одна пара совпадающих\n//09. Точка с координатами (a, b) лежит в правой нижней координатной четверти\n//10. Точка с координатами (a, b) лежит в левой верхней или правой нижней координатной четверти\n\n\n}
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Вот описание задач.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                На каждый вопрос терминал даст несколько цифр и нужно ответить ему, верно ли поставленное условие для этих цифр или нет.\n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>var</t> data = <c>BOT</c>.<m>Terminal_Read</m>();(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Чтобы считать с терминала цифры, используем функцию BOT.Terminal_Read(), которая возвращает структуру.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              <i>Мы пока, конечно, не знаем, что такое структура, но, надеюсь, это нас не остановит.</i>\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<t>int</t> a = data.A; <t>int</t> b = data.B;\n<t>int</t> c = data.C; <t>int</t> d = data.D;(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Забрать из структуры нужные числа можно так.\n(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                После этого, надо ответить терминалу, верно ли условие текущей задачи для данных цифр.\n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <c>BOT</c>.<m>Terminal_Answer</m>( <t>bool</t> responce );(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Делаем это с помощью метода BOT.Terminal_Answer(bool responce).\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Я могу выдать вам темплейт для ответов терминалу.\n(-1,0)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n//01. Число A является положительным а число B является отрицательным\nfor (int i = 0; i < 10; i++) {\n   var td = BOT.Terminal_Read();\n   int a = td.A; int b = td.B;\n   bool responce = ??? //Write your expression here\n   BOT.Terminal_Answer(responce);\n}\n\n//02. A < B < C\nfor (int i = 0; i < 10; i++) {\n   var td = BOT.Terminal_Read();\n   int a = td.A; int b = td.B; int c = td.C;\n   bool responce = ??? //Write your expression here\n   BOT.Terminal_Answer(responce);\n}\n\n//03. Число A находится между числами B и C\nfor (int i = 0; i < 10; i++) {\n   var td = BOT.Terminal_Read();\n   int a = td.A; int b = td.B; int c = td.C;\n   bool responce = ??? //Write your expression here\n   BOT.Terminal_Answer(responce);\n}\n\n//04. Каждое из чисел A, B, C положительное\nfor (int i = 0; i < 10; i++) {\n   var td = BOT.Terminal_Read();\n   int a = td.A; int b = td.B; int c = td.C;\n   bool responce = ??? //Write your expression here\n   BOT.Terminal_Answer(responce);\n}\n\n//05. Хотя бы одно из чисел A, B, C положительное\nfor (int i = 0; i < 10; i++) {\n   var td = BOT.Terminal_Read();\n   int a = td.A; int b = td.B; int c = td.C;\n   bool responce = ??? //Write your expression here\n   BOT.Terminal_Answer(responce);\n}\n\n//06. Ровно два из чисел A, B, C являются положительными\nfor (int i = 0; i < 10; i++) {\n   var td = BOT.Terminal_Read();\n   int a = td.A; int b = td.B; int c = td.C;\n   bool responce = ??? //Write your expression here\n   BOT.Terminal_Answer(responce);\n}\n\n//07. A является двузначным\nfor (int i = 0; i < 10; i++) {\n   var td = BOT.Terminal_Read();\n   int a = td.A;\n   bool responce = ??? //Write your expression here\n   BOT.Terminal_Answer(responce);\n}\n\n//08. Среди трех данных целых чисел есть хотя бы одна пара совпадающих\nfor (int i = 0; i < 10; i++) {\n   var td = BOT.Terminal_Read();\n   int a = td.A; int b = td.B; int c = td.C;\n   bool responce = ??? //Write your expression here\n   BOT.Terminal_Answer(responce);\n}\n\n//09. Точка с координатами (a, b) лежит в правой нижней координатной четверти\nfor (int i = 0; i < 10; i++) {\n   var td = BOT.Terminal_Read();\n   int a = td.A; int b = td.B;\n   bool responce = ??? //Write your expression here\n   BOT.Terminal_Answer(responce);\n}\n\n//10. Точка с координатами (a, b) лежит в левой верхней или правой нижней координатной четверти\nfor (int i = 0; i < 10; i++) {\n   var td = BOT.Terminal_Read();\n   int a = td.A; int b = td.B;\n   bool responce = ??? //Write your expression here\n   BOT.Terminal_Answer(responce);  \n}\n\n}
ПРОДОЛЖИТЬ В ПАНЕЛИ:              ХОБА!\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Теперь вам остаётся только написать условие, для каждой задачи, что бы сформировать ответ терминалу.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Поехали.\n(-1,0)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <color="#A0A0ffff">&&</color> - И ( a && b = true если и a и b = true)\n<color="#A0A0ffff">||</color> - ИЛИ ( a || b = true если или a или b = true)\n<color="#A0A0ffff">!</color> - НЕ ( если a = false --- !a = true\n            если a = true --- !a = false )(-1,0)
ЖДАТЬ СОСТОЯНИЯ:                  TERMINAL
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-6b - Bool 2.---Level 001-06b

ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n\n\n\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                В этом уровне 8 индикаторов и один рубильник в конце.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Когда рубильник будет включён, уровень перевернётся, и станут доступны ещё восемь рубильников.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Их надо будет выставить в состояние, соответствующее индикатору - если он горит, то включить рубильник, если не горит - то выключить.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Состояние индикаторов рандомизируется при старте скрипта.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Что-то похожее мы уже делали, но тогда, индикатор висел прямо над рубильником - мы узнавали его состояние, сразу переключали рубильник и шли к следующему.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              А теперь, нужно будет сначала запомнить состояние всех восьми рубильников, перевернуть уровень, включив главный рубильник, и только потом попереключать рубильники в соответствии с запомненными состояниями индикаторов.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                В чём прикол? А в том, что вам понадобится в цикле запоминать восемь <b>разных</b> значений: в каждой итерации цикла - новое значение.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Я очень хотел бы посмотреть, как вы будете создавать в каждой новой итерации новую переменную. И я имею в виду именно <i>новую</i>, а не перезаписывать старую, ведь тогда, то, что в ней было, потеряется...\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Не, ну, то есть, можно, конечно, написать ~20и килобайтный код, который будет делать это всё вообще без циклов, но это слишком казуально.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Тут поможет такая штука, как массивы (анг. Array - множество).\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Это, собственно говоря, способ запихнуть в одну переменную сразу несколько значений и обращатся к ним по индексу.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ну то есть у вас в итоге будет одна переменная, скажем "x", но в ней будет храниться несколько отдельных элементов: x[1], x[2], x[3]... и т.д., сколько захотите.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Как и переменные, массивы строготипизированы, то есть в массиве типа int все элементы будут int, и в него нельзя запихать элементы bool или float.\n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>int</t>[] my_array_of_int;\n<t>bool</t>[] b;\n<t>float</t>[] f_arr;(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Объявляются они почти как и обычные переменные, по шаблону "тип_данных имя_переменной;", только после типа, идут квадратные скобки.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Как и в случае с переменными, сразу после объявления, они, как бы, уже существуют, но не инициализированы, т.е. их значение равно <i>null</i> - <i>ничто</i>.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Любое обращение к такому массиву, как и к обычной неинициализированной переменной, приведёт к ошибке <i>null reference exception</i>.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>int</t>[] my_array_of_int;\nmy_array_of_int = <instr>new</instr> <t>int</t>[8];(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Инициализируются массивы вот так.\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n\n<t>bool</t>[] b_arr = <instr>new</instr> <t>bool</t>[8];(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Или можно сразу, во время объявления, вот так.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              В обоих случаях будет создан массив, размером в 8 элементов. В первом случае это будет массив int-ов, а во втором - массив bool-ов.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Весь массив, в этом случае будет заполнен <i>значениями типа по умолчанию</i>: для всех числовых типов (int, float, double, decimal) - это 0, а для bool-а - false.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>int</t>[] my_array = <instr>new</instr> <t>int</t>[8];(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Короче говоря, в данном примере, после инициализации, мы получаем массив размером в 8 элементов, забитый нулями.\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<t>int</t> a = my_array[3];(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Чтобы получить n-ный элемент, просто указываем его индекс в скобках.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<c>BOT</c>.<m>Move</m>( my_array[5] );(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Как и переменную, элемент массива можно сразу использовать в аргументах функций и методов.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<c>BOT</c>.<m>Rotate</m>( my_array[5] * 2 );(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Также можно использовать элементы в арифметических выражениях (или, в случае с bool - в логических).\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>int</t>[] my_array = <instr>new</instr> <t>int</t>[8];\n<t>int</t> a = 5;\n<t>int</t> b = my_array[a];(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Для доступа к n-ному элементу не обязательно использовать константу - подойдёт и другая переменная типа int. Эта особенность просто неоценимо полезна в циклах.(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>int</t>[] my_array = <instr>new</instr> <t>int</t>[8];(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Однако - и это важно помнить - при инициализации, мы указываем <i>количество</i> элементов в массиве, но индексация начинается с нуля, по этому самый последний элемент этого массива из 8и элементов - это my_array[7].\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Потому что у него есть элементы 0, 1, 2, 3, 4, 5, 6 и 7. А всего их получается 8, можете пересчитать, я подожду.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Магия!\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                При попытке обратиться к элементу с индексом 8, закономерно получим ошибку "index was outside the bounds of the array".\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \nmy_array[0] = 42;\nmy_array[3] = 771;(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Несложно догадаться, что чтобы присвоить элементу какое-то значение, нужно не забыть указать его индекс.\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \nmy_array = 321 <cmt>//This will throw an error;</cmt>(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Попытавшись присвоить что-нибудь не отдельному элементу массива, а самому массиву, мы получим ошибку типа "can not implicitly convert int to int[]", т.е. "не могу преобразовать число в массив чисел, в самом деле, где это видано, совсем сдурели что ли?" (вольный перевод - Р.О. Бот).\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Ну и посленее, что можно сказать про массивы - если очень хочется, можно присвоить всем элементам значения прямо во время инициализации.\n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>int</t>[] my_array_of_int = <instr>new</instr> <t>int</t>[4]{ 24, 72, 36, 52 };\n<t>bool</t>[] bool_arr = <instr>new</instr> <t>bool</t>[2]{ true, false };(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Для этого, после инициализации, в фигурных скобках указываем все элементы через запятую.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Разумеется, их количество должно соответствовать указанному размеру массива. Иначе, что? Правильно - ошибка.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Размер массива нельзя изменить после того как он инициализирован. Соответственно добавить или удалить из него элементы не получится.\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \nmy_array_of_int = <instr>new</instr> <t>int</t>[30];(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Его можно заново переинициализировать, с новым размером, но все старые данные из него пропадут, т.к. это будет уже <i>новый</i> массив, о чём прозрачно намекает ключевое слово <i><instr>new</instr></i> при инициализации.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Ну вроде информации достаточно. Поехали.\n(-1,0)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ЖДАТЬ СОСТОЯНИЯ:                  Switch
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-7 - Массивы---Level 001-07

ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n\n\n\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                Хорошо. Значит тут у нас 27 индикаторов - 3х3х3.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Как обычно, сначала нужно снять с них со всех показания. Затем, дёрнуть за главный рубильник, который заменит все индикаторы на рубильники, и, наконец, выставить свежепоявившиеся рубильники в состояние, соответствующих им индикаторов.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Я стою на платформе, которая умеет меня телепортировать по нужным координатам с помощью метода <c>Platform</c>.<m>MoveTo</m>(<t>int</t> x, <t>int</t> y, <t>int</t> z);\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Доступные координаты - от 0,0,0 (правый-нижний-передний индикатор) до 2,2,2 (левый-верхний-задний)\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Плюс ещё надо будет портнуться на изначальную координату -1,1,1 что бы повернуть главный рубильник.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                В принципе, всё это не очень сложно сделать и с обычным массивом, но тут у нас вложенные циклы вырисовываются (ну, что бы перемещатся по координатам), а в них у нас не получится организовать счётчик от нуля до 26и.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Вместо этого там получится три счётчика - от нуля до 2х каждый.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Перевести три счётчика 0-2 в один 0-26 дело не хитрое: "<t>int</t> counter = x*9 + y*3 + z;". Но давайте попробуем решить эту задачу более удобным способом.\n(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Для таких случаем у нас есть многомерные массивы.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Даже песня такая есть: "Мно-го-мер-ны-е мас-си-вы, тум-да-да-да..."\n(-1)
ПРОИГРАТЬ ЗВУК:                   0,0
ЖДАТЬ:                            5
ВЕРНУТЬ ГРОМКОСТЬ                 
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ну, почти попал...\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Так, что это вообще такое?\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ну, если для обычного, одномерного массива, нам нужно указать одну циферку - индекс - что бы добраться до содержимого, то в двумерном нужно будет две циферки (два индекса).\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              В трёх-мерном - три, в четырёх-мерном - четыре, и так далее.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Нет предела количеству измерений у массива - есть лишь адекватность программиста.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Вообще-то предел измерений есть - 32. Но это настолько до хрена, что в жизни ни кому никогда не понадобится.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              3х-мерные массивы уже встречаются довольно редко. 4х-мерные - <i>крайне</i> редко. А если у вас в программе используются 5и, и более -мерные, велика вероятность что вашей программе нужно пройти медосмотр и порефакториться...\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Если одномерный массив <t>int</t>[] - это ряд чисел, то двумерный можно представить как таблицу. Трёхмерный - как кубик. А четырёхмерный - как хороший способ сожрать всю память одной командой, и не подавится.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              На самом деле, четырёхмерный массив сложно визуализировать, но по сути это просто означает, что для доступа к его элементу, вам нужно указать четыре индекса.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Объявляется многомерный массив так-же, как и одномерный, только в квадратных скобках ставятся запятые, соответствющие количеству измерений минус один.\n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>int</t>[,] array_2_dimensions;(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Т.е. <i>ноль</i> запятых для одномерного массива, одна запятая для двухмерного - как в примере ниже, \n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<t>int</t>[,,] array_3_dimensions;(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              две - для трёх-мерного, три - для четырёхмерного, и т.д...\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>int</t>[,] a = new int[2,3] { { 10, 0, 12 }, { 13, 45, 72 } };\n<cmt>//Получим следующее:</cmt>\n<cmt>//a[0,0] = 10, a[0,1] = 0, a[0,2] = 12</cmt>\n<cmt>//a[1,0] = 13, a[1,1] = 45, a[1,2] = 72</cmt>(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                А вот так, можно заполнить многомерный массив значениями... можно я не буду это комментировать? Просто посмотрите на пример.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Грубо говоря, заполняем сначала первый элемент певого измерения, затем второй его элемент.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              По аналогии с таблицей - сначала первую строчку, затем вторую. Где каждая из строчек - это три столбца (одномерный массив из 3х элементов).\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Схожим образом можно заполнить и трёх-мерный, и 10-и мерный, но уже на 3х мерном вы окончательно запутаетесь в этих фигурных скобках.\n(-1,0)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n  int[,,] arr = new int[5,9,14];\n  for(int a=0; a<5; a++) {\n    for(int b=0; b<9; b++) {\n      for(int c=0; c<14; c++) {\n        arr[a,b,c] = Random.Range(0, 500);\n      }\n    }\n  }\n\n}
ПОКАЗАТЬ КРАСНУЮ СТРЕЛКУ:         (-560,8)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Такие массивы проще заполнять во вложенных циклах.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Что-ж, пора рубить рубильники, а то они ждать устали.\n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>int</t>[,] arr1 = new int[2,3];\n<t>int</t>[,,] arr2 = new int[3,7,2];(-1,0)
СКРЫТЬ КРАСНУЮ СТРЕЛКУ:           
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ЖДАТЬ СОСТОЯНИЯ:                  Switch
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-7b - Массивы многомерные---Level 001-07b

ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n\n\n\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                В этом уровне против нас играет хитрый пол с картошкой.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Каждый раз, когда скрипт запускается - конфигурация пола и количество картошки на нём изменяется.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Всё что нужно сделать - это прочесать весь пол, собрать данные о количестве картошки на каждой клетке, и сообщить эту информацию терминалу.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>float</t> <c>BOT</c>.<m>GetFloorSquare</m>();(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Прочесать такой нестандартный пол, нам поможет знакомая функция GetFloorSquare().\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Напоминаю, что она возвращает площадь пола, на котором я стою. \n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              В данном случае, поскольку каждый фрагмент пола одного цвета - это отдельный пол, шириной в 1 метр, то по сути, данная функция вернёт <i>длинну</i> текущего отрезка пола.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<t>int</t> <c>BOT</c>.<m>CheckPotatoes</m>();(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              А количество картошки на клетке подо мной, нам возвращает функция <c>BOT</c>.<m>CheckPotatoes</m>().\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Осталось, стало быть решить, как мы будем хранить информацию о количестве картошки.\n(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Всего отрезков пола 5 - это видно: зелёный, жёлтый, красный, синий... и ещё один зелёный - у дизайнера цвета кончились.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Длинна каждого отрезка будет каждый раз разной.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Можно было бы взять обычный двухмерный массив <t>int</t>[5,100] - что б с запасом. Не может же фрагмент пола быть длинной больше чем 100!\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Или может?...\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Да не, ерунда...\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Но есть проблема: здешний терминал хочет получить от нас в качестве ответа зубчатый массив, и никакой другой. На простой двухмерный массив он будет ругаться.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ну что, погнали?\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              А, ну да, я ж забыл объяснить...\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Зубчатый массив (jagged array), это, по сути массив массивов.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Т.е. одномерный массив, каждый элемент которого - это другой одномерный массив.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Таким образом, мы получаем функционал такой же как и у двухмерного массива, но с той разницей, что в зубчатом массиве, каждая строка таблицы - если проводить аналогию с таблицей - может иметь разное количество столбцов.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              При больших объёмах данных это может сильно сэкономить объём используемой памяти.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>int</t>[][] arr;(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Объявляется такая штука вот таким образом. Также, как и обычный массив, только вместо одной пары квадратных скобок ставим две.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ну, или можно три - что бы получить 3х-мерный зубчатый массив. Можно пять, десять, двадцать - максимальный ранг ограничен реализацией .net framework, но до 32х можно вроде бы везде.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              В любом случае, это уже далеко за пределами нашей текущей задачи.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                А вот инициализировать такой массив уже хитрее, чем обычный.\n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>int</t>[][] arr = new <t>int</t>[3][];(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              При объявлении, мы можем инициализировать только первое измерение - типа, количество строк в таблице.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \narr[0] = new <t>int</t>[3];\narr[1] = new <t>int</t>[17];\narr[2] = new <t>int</t>[9];(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Поскольку каждый элемент такого массива, это другой, независимый массив, и все элементы могут быть разного размера, то инициализировать каждый элемент нужно отдельно.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>int</t>[][] arr = new <t>int</t>[2][];\narr[0] = new <t>int</t>[4]{47,16,38,19};\narr[1] = new <t>int</t>[2]{91,37};(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Вот так можно сразу запихнуть в массив данные.\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<t>int</t> x = arr[0][3];\narr[1][0] = 76;(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              И вот так обратиться к отдельным элементам - в первых квадратных скобках указываем строку, во вторых - столбец.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Вроде всё. Поехали!\n(-1,0)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ЖДАТЬ СОСТОЯНИЯ:                  TERMINAL
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-7c - Массивы зубчатые---Level 001-07c

ПОКАЗАТЬ В ПАНЕЛИ:                Ну вот и настало время твоего первого боя.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Твой враг будет агрессивен и очень силён. От его шагов меркнет небо и армии разбегаются в страхе.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Узри же, великого...(-1)
ПРОИГРАТЬ ЗВУК:                   0,-1
ЖДАТЬ:                            2
ПРОИГРАТЬ ЗВУК:                   1,-1
АКТИВИРОВАТЬ ОБЪЕКТ:              0
ПОКАЗАТЬ В ПАНЕЛИ:                Окей, это просто бомба.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                К сожалению, чтобы пройти дальше, её, таки, придётся уничтожить.(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Итак, особенности бомбы:\n(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                - Фигачить бомбу, как и любого врага, можно методом <c>BOT</c>.<m>Fight</m>(). Для этого, нужно стоять на клетке перед врагом и быть направленным в его сторону.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              - Количество единиц здоровья бомбы заранее не известно (каждый раз, когда скрипт запускается - оно меняется).\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              - Когда у бомбы заканчивается здоровье, она немного ждёт и делает БУМ.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              - В момент бума, лучше не стоять рядом с ней. Все роботы, в радиусе трёх клеток от БУМкающей бомбы, трагически погибают.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <instr>while</instr> ( <color="#A0A0ffff">true</color> )(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Предлагаю сделать беcконечный цикл, в теле которого - фигачить бомбу и проверять её здоровье.(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n{\n  <cmt>//фигачить бомбу и проверять здоровье;</cmt>\n  <instr>if</instr> (здоровье ≺= 0) { <instr>break</instr>; }\n}(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                В момент, когда её здоровье станет меньше или равно нулю - выйти из цикла, и свалить.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Для выхода из цикла есть команда <instr>break</instr>.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Проблема, стало быть, лишь в том, чтобы узнать здоровье бомбы.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Тут поможет функция <c>BOT</c>.<m>GetClosestEnemyInfo</m>() - она возвращает информацию о ближайшем враге.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Тип возвращаемого этой функцией значения - это структура EnemyInfo.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>struct</t> <c>EnemyInfo</c> {\n  <t>int</t> HP; <cmt>//Здоровье</cmt>\n  <t>int</t> EP; <cmt>//Заряд</cmt>\n  <t>float</t> pos_x <cmt>//координата врага x на поле</cmt>\n  <t>float</t> pos_y <cmt>//координата врага y на поле</cmt>\n}(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Структура - это всего лишь несколько переменных объединённых в одну.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Как видно из объявления, в структуре есть здоровье врага. И хранится оно в переменной HP типа int.(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <c>EnemyInfo</c> en = <c>BOT</c>.<m>GetClosestEnemyInfo</m>();\n<t>int</t> health = en.HP;(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Пользоваться этим можно так: \n- объявляем переменную типа EnemyInfo, присваиваем ей информацию о текущем враге, а чтобы узнать здоровье, обращаемся к нужной переменной структуры через точку.\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n\n<cmt>//или так</cmt>\n<t>int</t> health = <c>BOT</c>.<m>GetClosestEnemyInfo</m>().HP;(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ну, или, если вся структура не нужна, можно сразу запросить здоровье из функции, без промежуточной переменной. Также, через точку.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Если использовать первый способ, то можно подумать, что достаточно получить структуру EnemyInfo вне цикла, а в теле цикла лишь проверять en.HP. Но это не сработает.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Цифры в полученной структуре сами по себе менятся не будут. Соответственно условие en.HP ≺= 0 не сработает никогда, и я буду вечно дубасить бомбу, пока она меня не взорвёт.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Чтобы обновить структуру, нужно её переполучить с помощью GetClosestEnemyInfo(), которая вернёт актуальную структуру на момент выполнения команды.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ну, или просто воспользоватся вторым способом.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Вперёд!(-1,0)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ЖДАТЬ СОСТОЯНИЯ:                  ScriptStopped && noenemyleft
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-8 - Structures - First Battle.---Level 001-08

ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n\n\n\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                Ой, сколько бомб...\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ну, в целом, ничего нового.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ездим, разминируем, любуемся пейзажем...\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              В цикле это сделать не получится, потому что ехать нужно каждый раз в разное место, и этот код не получится зациклить.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              В итоге, тут получится довольно много кода. Причём та часть, в которой мы дубасим бомбу, пока она не загорится, будет повторена 4 раза, в абсолютно одинаковом виде.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Нехорошо.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Ты знаешь, ты можешь писать свои методы и функции. Они помогают избавится от повторений одинакового кода.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              До сих пор, весь код ты тоже писал внутри функции. Это функция Start().\n(-1)
ПОКАЗАТЬ КРАСНУЮ СТРЕЛКУ:         (-560,1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Вот это - её определение.(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Ключевое слово "void" означает, что функция ничего не возвращает, т.е. является методом.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Пустые скобки означают, что у функции нет параметров.\n(-1)
ПОКАЗАТЬ КРАСНУЮ ОБВОДКУ:         (0,3,100,10)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ну, а дальше, между фигурных скобок, собственно, идёт тело функции, т.е. код, который выполняется при её вызове.(-1)
СКРЫТЬ КРАСНУЮ СТРЕЛКУ:           
ПОКАЗАТЬ В ПАНЕЛИ:                Функция Start() вызывается автоматически, при запуске скрипта. Это, так называемый, EntryPoint - место, с которого начинает выполнятся программа, при её запуске.\n(-1,0)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n\n\n\n\n}\n\nvoid KillBomb() \n{\n\n\n\n\n\n\n}
СКРЫТЬ КРАСНУЮ ОБВОДКУ:           
ПОКАЗАТЬ КРАСНУЮ СТРЕЛКУ:         (-560,13)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Но, никто не мешает, по образу данной функции, создать свою. Скажем KillBomb().(-1)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n\n\n\n\n}\n\nvoid KillBomb() \n{\n  while (true)\n  {\n    BOT.Fight();\n    //Get bomb HP somehow\n    if (HP <= 0) { break; }\n  }\n}
ПОКАЗАТЬ В ПАНЕЛИ:                Внутрь мы запихнём код, который будет взрывать бомбу.\n(-1,0)
ПОКАЗАТЬ КРАСНУЮ СТРЕЛКУ:         (-560,4)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n  //Go to bomb\n  KillBomb(); //This call our function and kill the bomb\n\n\n\n\n\n\n}\n\nvoid KillBomb() \n{\n  while (true)\n  {\n    BOT.Fight();\n    //Get bomb HP somehow\n    if (HP <= 0) { break; }\n  }\n}
ПРОДОЛЖИТЬ В ПАНЕЛИ:              В основном же коде, нам останется только подойти к бомбе, и вызвать нашу новую функцию.\n(-1)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n  //Go to bomb 1\n  KillBomb(); //This call our function and kill the bomb\n  //Go to bomb 2\n  KillBomb();\n  //Go to bomb 3\n  KillBomb();\n  //Go to bomb 4\n  KillBomb();\n}\n\nvoid KillBomb() \n{\n  while (true)\n  {\n    BOT.Fight();\n    //Get bomb HP somehow\n    if (HP <= 0) { break; }\n  }\n}
ПРОДОЛЖИТЬ В ПАНЕЛИ:              И повторить четыре раза.\n(-1)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n}
СКРЫТЬ КРАСНУЮ СТРЕЛКУ:           
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Попробуй.(-1)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ЖДАТЬ СОСТОЯНИЯ:                  ScriptStopped && noenemyleft
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-9 - Functions.---Level 001-09

ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start () \n{\n\n\n\n\n\n\n\n\n}
ПОКАЗАТЬ В ПАНЕЛИ:                Лежебоке Лодыревне Спать, менеджеру отдела по развитию коррупции, активистке, атеистке, феминистке, арфистке, химчистке и просто, хорошему человеку, приходит на почту много спама.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Она попросила помочь обработать почту в целом, и отфильтровать спам в частности.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Почта будет выдаваться с помощью уже знакомого терминала.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Терминал выдаст 10 рандомных е-мейлов, которые надо будет обработать.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Забираем из терминала структуру с помощью <t>var</t> data = <c>BOT</c>.<m>Terminal_Read</m>();\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Вытаскиваем из неё письмо: <t>string</t> mail = data.str;\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Обрабатываем это письмо, и отвечаем терминалу с помощью <c>BOT</c>.<m>Terminal_Answer</m>(<t>string</t>[] parsed_mail);\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              (Да, в этот раз нужно будет отвечать терминалу массивом <t>string</t>[] из двух элементов, что в них должно быть - я объясню).\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              И всё вот это вот, нужно сделать в цикле 10 раз. Но не заморачивайтесь - вот темплейт.\n(-1)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start ()\n{\n  for (int i = 0; i < 10; i++) {\n    var d = BOT.Terminal_Read();\n    string mail = d.str;\n    string[] parsed_mail = new string[2]{};\n\n    //Insert you code here\n\n\n\n    BOT.Terminal_Answer(parsed_mail);\n  }\n}\n
ПОКАЗАТЬ В ПАНЕЛИ:                В темплейт уже вписаны обращения к терминалу, и получение е-мейла в переменную <t>string</t> mail;\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              А так-же ответ, массивом <t>string</t>[] parsed_mail.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Вам нужно только обработать переменную "mail" и поместить в "parsed_mail".\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Краткое содержание того, что, собственно, нужно сделать с письмом:\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              - 1. Надо создать заголовок письма - это должны быть первые 140 символов и три точки если письмо длинее 140 символов, или всё письмо если оно короче.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              - 2. Если имя или отчество Лежебоки Лодыревны начинается с маленькой буквы - заменить её на заглавную (Лежебока Лодыревна отключается, если видит своё имя/фамилию с маленькой буквы).\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                - 3. Нужно отфильровать почту на спам - пометить спамом все письма, содержащие 'вы выиграли' или 'одобрен кредит'. Если содержит - добавить перед заголовком строку <str>"(СПАМ) "</str>.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              - 4. Заменяем все "а" на "о" а "о" на "а" (Лежебока Лодыревна человек своеобразный, и ей так легче читать).\n(-1)
ВСТАВИТЬ СКРИПТ В РЕДАКТОР:       \nvoid Start ()\n{\n  for (int i = 0; i < 10; i++) {\n    var d = BOT.Terminal_Read();\n    string mail = d.str;\n    string[] parsed_mail = new string[2]{};\n\n    //1. Надо создать заголовок письма - это должны быть первые 140 символов и три точки ("...") если письмо длинее 140 символов, или всё письмо если оно короче.\n    //2. Если имя или отчество Лежебоки Лодыревны начинается с маленькой буквы - заменить её на заглавную (Лежебока Лодыревна отключается, если видит своё имя/фамилию с маленькой буквы).\n    //3. Нужно отфильровать почту на спам - пометить спамом все письма, содержащие 'вы выиграли' или 'одобрен кредит'. Если содержит - добавить перед заголовком строку "(СПАМ) ".\n    //4. Заменяем все "а" на "о" а "о" на "а".\n\n    //Insert you code here\n\n\n\n    BOT.Terminal_Answer(parsed_mail);\n  }\n}\n
ПОКАЗАТЬ В ПАНЕЛИ:                Вот вам все задания комментариями в темплейт.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              А теперь - главное: как это всё вообще делать.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Я уже упоминал, что тип string - это вообще-то класс. А это значит, что у него есть свои методы и функции.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              (Для справки: остальные простые типы - всякие int, decimal и т.д. - это структуры, которые, в принципе, не так уж сильно от классов отличаются, и тоже имеют свои методы и функции, но они не прикольные).\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>string</t> greeting = <str>"Привет, я - БОТ."</str>;(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Объявляя переменную типа <t>string</t>, и присваивая ей значение, вы создаёте <i>экземпляр</i> (instance) класса <t>string</t>, и можете обращаться к его методам через эту переменную.\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \ngreeting.<m>Replace</m>(<str>"я"</str>, <str>"ы"</str>);(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Например, у класса <t>string</t> есть функция <m>Replace</m>, которая заменяет в строке одну букву (или слово), на другую букву (или слово).\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Осторожно - подстава!\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Все вот эти функции (как и вообще любые функции), <i>возвращают</i> результат своей работы, но не меняют исходную переменную. То есть, после выполнения кода ниже - переменная "greeting" не изменится!\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:        <cmt>//безполезный вызов</cmt>(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              По сути, после выполнения такого кода, вообще ничего не изменится - функция вернёт результат, но он уйдёт в никуда.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \ngreeting = greeting.<m>Replace</m>(<str>"я"</str>, <str>"ы"</str>);\n<cmt>//в greeting теперь лежит - "Привет, <i>ы</i> - БОТ."</cmt>(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Что бы реально заменить все <str>"я"</str> на <str>"ы"</str> в исходной строке, присваиваем результат функции обратно нашей переменной.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Думаю тут понятно, что и первым (что меняем) и вторым (на что меняем) аргументом, может быть и буква, и символ, и набор букв или символов, и всё в перемешку... короче, любая валидная строка или другая переменная типа <t>string</t>.\n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>string</t> greeting = <str>"Привет, я - БОТ."</str>;\ngreeting = greeting.<m>Replace</m>(<str>"Привет"</str>, <str>""</str>);\n<cmt>//в greeting теперт лежит - ", я - БОТ."</cmt>(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Вторым аргументом может даже быть пустая строка, тогда результатом будет полное уничтожение найденных подстрок в исходной строке.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>string</t> t = <str>"Привет, я - БОТ."</str>;(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Коротко о других функциях класса <t>string</t> (готовтесь, их не мало, но они все простые).\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<t>string</t> t1 = t.<m>ToLower()</m>; <cmt>//"привет, я - бот."</cmt>(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              - <t>string</t> <m>ToLower</m>() - возвращает исходную строку в нижнем регистре.\n(-1)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<t>string</t> t2 = t.<m>ToUpper()</m>; <cmt>//"ПРИВЕТ, Я - БОТ."</cmt>(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              - <t>string</t> <m>ToUpper</m>() - возвращает исходную строку в верхнем регистре.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>string</t> t = <str>"Привет, я - БОТ."</str>;\n<t>bool</t> b1 = t.<m>Contains</m>(<str>","</str>); <cmt>//true</cmt>\n<t>bool</t> b2 = t.<m>Contains</m>(<str>"Привет"</str>); <cmt>//true</cmt>\n<t>bool</t> b3 = t.<m>Contains</m>(<str>"к"</str>); <cmt>//false</cmt>(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                - <t>bool</t> <m>Contains</m>(<t>string</t> substring) - возвращает <t>bool</t>, содержится-ли указанная первым аргументом подстрока в исходной строке.\n(-1,0)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>string</t> t = <str>"Привет, я - БОТ."</str>;\n<t>string</t> t1 = t.<m>Substring</m>(3); <cmt>//"вет, я - БОТ."</cmt>\n<t>string</t> t2 = t.<m>Substring</m>(10); <cmt>//"- БОТ."</cmt>(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                - <t>string</t> <m>Substring</m>(<t>int</t> index) - возвращает подстроку, начиная с позиции <i>index</i> (индексация начинается с нуля, т.е. первый символ, на самом деле нулевой).\n(-1,0)
ПРОДОЛЖИТЬ В НИЖНЕЙ ПАНЕЛИ:       \n<t>string</t> t3 = t.<m>Substring</m>(2, 5); <cmt>//"ивет,"</cmt>(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              - <t>string</t> <m>Substring</m>(<t>int</t> index, <t>int</t> count) - перегрузка функции <m>Substring</m> с двумя аргументами типа <t>int</t>. Возвращает некоторое количество (<i>count</i>) символов, начиная с позиции <i>index</i>. В примере, мы получили 5 символов, начиная с похиции 2.\n(-1)
ПОКАЗАТЬ В НИЖНЕЙ ПАНЕЛИ:         <t>string</t> t = <str>"Привет, я - БОТ."</str>;\n<t>int</t> i = t.<m>Length</m>; <cmt>//16</cmt>(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Ну, и на конец, свойство Length. Возвращает просто количество символов в строке.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Его фишка в том, что оно не функция. Оно - свойство. С такими зверями мы ещё не сталкивались.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ну, с точки зрения использования, свойство отличается от функции только тем, что у свойства нет никаких аргументов, стало быть и никакие скобки указывать не надо.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Как запомнить, где свойство, а где функция?\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              А вот никак. Бугагагага.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Нет, серьёзно. К сожалению, это можно только либо запомнить, либо каждый раз лезть в бот-о-педию.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              В будущем, подсказка кода вам будет говорить, что свойство а что функция, но пока только так...\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Возвращаемся к заданиям, и попробуем разобратся как их решать.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Отдавать терминалу надо массив <t>string</t> из двух элементов, где первый элемент будет заголовком письма, а второй - самим письмом.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                1. Надо создать заголовок письма - это должны быть первые 140 символов и три точки если письмо длинее 140 символов, или всё письмо если оно короче.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              С помощью свойства <m>Length</m> узнаём количество букв в письме, и если получилось меньше чем 141, суём в заголовок (первый элемент результирующего массива) всё письмо. А если больше - то с помощью функции <m>Substring</m> отдираем от письма первые 140 символов, добавляем к ним "...", и то что получилось так-же суём в заголовок.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                2. Если имя или отчество Лежебоки Лодыревны начинается с маленькой буквы - заменить её на заглавную.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Тупо, с помощью <m>Replace</m> заменяем <str>"<b>л</b>ежебока"</str> на <str>"<b>Л</b>ежебока"</str>.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Однако, это не проконает, если имя будет указано в другом падеже (<str>лежебоке</str>, например).\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Не проблема - заменим не <str>"лежебок<b>а</b>"</str>, а <str>"лежебо<b>к</b>"</str>. Такая замена должна сработать с любым падежом.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Ну, и так-же с отчеством.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                3. Нужно отфильровать почту на спам - если письмо содержит 'вы выиграли' или 'одобрен кредит', то добавить перед заголовком строку <str>"(СПАМ) "</str>.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              С помощью <m>Contains</m> узнаём, есть ли в письме указанные подстроки. И если есть - с помощью конкатенации изменяем заголовок указанным образом.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Но есть ньюанс: <m>Contains</m> (как и <m>Replace</m>, кстати) - регистрозависим, и <m>Contains</m>(<str>"вы выиграли"</str>) не обнаружит строку <str>"Вы выиграли"</str>, из-за заглавной буквы.\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Тоже не проблема - достаточно перед проверкой, всё письмо перевести в нижний регистр с помощью функции <m>ToLower</m>().\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Только не запихивайте результат обратно в письмо, т.к. само письмо нам нужно в правильном регистре. Используйте для этого временную переменную.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                4. Заменяем все "а" на "о" а "о" на "а"\n(-1,0)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Если, при помощи <m>Replace</m>, сначала заменить <str>"а"</str> на <str>"о"</str>, а затем <str>"о"</str> на <str>"а"</str>, то во втором шаге будут заменены все буквы "о", включая те, которые вы получили на первом шаге.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              А это не то, что имеется в виду в задании.\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Простой workaround - заменить сначала все <str>"а"</str> на какую ни-будь кракозябру, которая точно не должна встретится в письме (что-то типа <str>"ъыъ$@@#?#@@$щёщ"</str>, или, не знаю... придумайте что ни будь).\n(-1)
ПРОДОЛЖИТЬ В ПАНЕЛИ:              Затем, меняем <str>"о"</str> на <str>"а"</str>, и, наконец, третим шагом, меняем обратно кракозябру на <str>"о"</str>.\n(-1)
ПОКАЗАТЬ В ПАНЕЛИ:                Не то, что б это прям идеальный способ, т.к. никогда не знаешь, какие кракозябры могут попасться в письмах... Тут, главное, придумать кракозябру, которая там попадётся с наименьшей вероятностью.\n(-1,0)
ПОКАЗАТЬ В ПАНЕЛИ:                Что ж, поехали. Удачи!\n(-1,0)
СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
ЖДАТЬ СОСТОЯНИЯ:                  TERMINAL
ЗАКОНЧИТЬ УРОВЕНЬ:                Level 1-10 - class string.---Level 001-10

СКРЫТЬ ПАНЕЛЬ ДИАЛОГА             
СКРЫТЬ НИЖНЮЮ ПАНЕЛЬ ДИАЛОГА      
СКРЫТЬ КНОПКИ УПРАВЛЕНИЯ          
ЖДАТЬ СОСТОЯНИЯ:                  ETERNAL
ЗАКОНЧИТЬ УРОВЕНЬ:                Level Chapter Complete---Level Chapter Complete

